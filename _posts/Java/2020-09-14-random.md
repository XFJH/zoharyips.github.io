---
layout: post
title: Java - 学习与思考 Java 中的随机数与随机数生成器
categories: Java
keywords: [random, RNG, PRNG, java random, SecureRandom, Random, Math.rand, ThreadLocalRandom]
image: images/wallpaper/schrodinger_error_correction_cat.jpg
lang: java
search: true
qrcode: true
catalogue: true
prism: true
mathjax: true
description: 真正的随机数就像薛定谔的猫，你得去量子世界中才能寻找到
---

## 线性同余法

Java 的 Random 类使用线性同余方法生成伪随机序列，是一个线性同余发生器。{线性同余发生器}(**L**inear **C**ongruential **G**enerator) 是
一种能产生具有不连续计算的伪随机序列的分段线性方程的算法，它代表了最古老和最知名的伪随机序列生成器算法之一，其理论相对容易理解，并且易于实现和快速，
特别是在可以通过存储位截断提供模运算的计算机硬件上。

### 定义

线性同余方法的基本思想是通过对前一个数进行线性运算并取模，从而得到下一个数。其循环关系定义为：

$$
X_{n+1} = (aX_n + c) \; mod \; m
$$

符号 | 范围 | 描述
:-: | :-: | :-
$$X$$ |  | 随机数列
$$m$$ | $$0 \lt m$$ | 模数
$$a$$ | $$0 \lt a \lt m$$ | 乘数
$$c$$ | $$0 \le c \lt m$$ | 增量
$$X_0$$ | $$0 \le X_0 \lt m$$ | 初始值

当 $$a = 0$$ 时，为**和同余法**，当 $$c = 0$$ 时为{乘同余法（乘法同余发生器）}(**M**ultiplicative **C**ongruential **G**enerator)，
当 $$a != 0 \&\& c != 0$$ 时为**混合同余法**。

### 生成伪随机序列

线性同余方法生成的产生的随机序列的均匀性和随机性取决于乘数、增量与模数。三者的组合可以多种多样，只要能保证有较好的均匀性和高随机性即可。

生成的随机序列最大周期为 m，即从随机数开始工作后，要生成一个已生成过的数，最久可以在 m 次后才生成。虽然最大周期为 m，但通常情况下周期都小于 m，要使得
周期达到最大，应满足：

1. $$c$$ 和 $$m$$ 互质；
2. $$m$$ 的所有质因数都能整除 $$A - 1$$；
3. 若 $$m$$ 是 4 的倍数，$$A - 1$$ 也是；
4. $$a$$、$$c$$、$$X_0$$ 都比 $$m$$ 小；
5. $$a$$、$$c$$ 是正整数。

一个优秀的线性同余发生器应该做到：

1. 是一个完整周期的发生器，即在产生重复前，能生产出 0 到 m 之间所有的数。
2. 产生的序列看起来应当是随机的。

对于优秀的线性同余方法参数组合可以参考：[TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.99.6553&rep=rep1&type=pdf)

以上内容可以启发我们可以思考，线性同余法要做到随机与均匀分布，在于我们对特定的参数条件的选择。理想情况下，我们希望构造一个序列周期为 M，在周期内所有数字
仅出现一次，且数字出现的顺序足够随机。因此合格的随机数生成器必须是**特定参数条件下的线性同余发生器**。

### 伪随机性

正因为通过线性同余方法构建的伪随机数生成器的内部状态可以轻易地由其输出演算得知，所以此种伪随机数生成器属于**统计学伪随机数生成器**。

## java.util.Random

Random 类是 Java 中较为常用的随机数生成类，也是其他随机数生成工具的父类，定义了获取随机数各方法的基本协议。

1. 使用 48 位的随机种子。

2. 通过{线性同余方程}(linear congruential formula)生成随机种子。

3. 伪随机，根据种子生成能通过随机性测试的随机数列，若种子初始值相同，则生成完全相同的随机数列。

4. 线程安全，但如果多个线程争用同一 Random 实例可能导致性能低下。

5. 非密码安全。

6. 可序列化。

* 随机数种子

    为保证线程安全，使用 Long 原子类型对 seed 进行存储。

    ~~~java
    /**
     * The internal state associated with this pseudorandom number generator.
     * (The specs for the methods in this class describe the ongoing
     * computation of this value.)
     */
    private final AtomicLong seed;
    ~~~

* 线性同余参数

    ~~~java
    private static final long multiplier = 0x5DEECE66DL;
    private static final long addend = 0xBL;
    private static final long mask = (1L << 48) - 1;
    ~~~
  
    对应了上文线性同余方法中的各个参数，那么我们可以推断 Random 中的循环定义方程为：
    
    $$
    X_{n+1} = (0x5DEECE66DL \times X_n + 0xBL) \; mod \; (1L << 48)
    $$
    
    在源码中，我们的推断也得到验证：
    
    ~~~java
    long oldseed, nextseed;
    AtomicLong seed = this.seed;
    do {
        oldseed = seed.get();
        nextseed = (oldseed * multiplier + addend) & mask;
    } while (!seed.compareAndSet(oldseed, nextseed));
    ~~~

    在计算 `nextseed` 时最后通过与运算的方式进行取模，是 jdk 中常有的操作。
