---
layout: post
title: Java - 学习与思考 Java 中的随机数与随机数生成器
categories: Java
keywords: [random, RNG, PRNG, java random, SecureRandom, Random, Math.rand, ThreadLocalRandom]
image: images/wallpaper/schrodinger_error_correction_cat.jpg
lang: java
search: true
qrcode: true
catalogue: true
prism: true
mathjax: true
description: 真正的随机数就像薛定谔的猫，你得去量子世界中才能寻找到
---

## 线性同余方法

Java 的 Random 类使用线性同余方法生成伪随机序列，是一个线性同余发生器。{线性同余发生器}(**L**inear **C**ongruential **G**enerator) 是
一种能产生具有不连续计算的伪随机序列的分段线性方程的算法，它代表了最古老和最知名的伪随机序列生成器算法之一，其理论相对容易理解，并且易于实现和快速，
特别是在可以通过存储位截断提供模运算的计算机硬件上。

### 定义

线性同余方法的基本思想是通过对前一个数进行线性运算并取模，从而得到下一个数。其循环关系定义为：

$$
X_{n+1} = (aX_n + c) \; mod \; m
$$

符号 | 范围 | 描述
:-: | :-: | :-
$$X$$ |  | 随机数列
$$m$$ | $$0 \lt m$$ | 模数
$$a$$ | $$0 \lt a \lt m$$ | 乘数
$$c$$ | $$0 \le c \lt m$$ | 增量
$$X_0$$ | $$0 \le X_0 \lt m$$ | 初始值

当 $$a = 0$$ 时，为**和同余法**，当 $$c = 0$$ 时为{乘同余法（乘法同余发生器）}(**M**ultiplicative **C**ongruential **G**enerator)，
当 $$a != 0 \&\& c != 0$$ 时为**混合同余法**。

### 生成伪随机序列

线性同余方法生成的产生的随机序列的均匀性和随机性取决于乘数、增量与模数。三者的组合可以多种多样，只要能保证有较好的均匀性和高随机性即可。

生成的随机序列最大周期为 m，即从随机数开始工作后，要生成一个已生成过的数，最久可以在 m 次后才生成。虽然最大周期为 m，但通常情况下周期都小于 m，要使得
周期达到最大，应满足：

1. $$c$$ 和 $$m$$ 互质；
2. $$m$$ 的所有质因数都能整除 $$A - 1$$；
3. 若 $$m$$ 是 4 的倍数，$$A - 1$$ 也是；
4. $$a$$、$$c$$、$$X_0$$ 都比 $$m$$ 小；
5. $$a$$、$$c$$ 是正整数。

一个优秀的线性同余发生器应该做到：

1. 是一个完整周期的发生器，即在产生重复前，能生产出 0 到 m 之间所有的数。
2. 产生的序列看起来应当是随机的。

对于优秀的线性同余方法参数组合可以参考：[TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.99.6553&rep=rep1&type=pdf)

以上内容可以启发我们可以思考，线性同余法要做到随机与均匀分布，在于我们对特定的参数条件的选择。理想情况下，我们希望构造一个序列周期为 M，在周期内所有数字
仅出现一次，且数字出现的顺序足够随机。因此合格的随机数生成器必须是**特定参数条件下的线性同余发生器**。

### 伪随机性

正因为通过线性同余方法构建的伪随机数生成器的内部状态可以轻易地由其输出演算得知，所以此种伪随机数生成器属于**统计学伪随机数生成器**。

## java.util.Random

Random 类是 Java 中较为常用的随机数生成类，也是其他随机数生成工具的父类，定义了获取随机数各方法的基本协议。

1. 使用 48 位的随机种子。

2. 通过{线性同余方程}(linear congruential formula)生成随机种子。

3. 伪随机，根据种子生成能通过随机性测试的随机数列，若种子初始值相同，则生成完全相同的随机数列。

4. 线程安全，但如果多个线程争用同一 Random 实例可能导致性能低下。

5. 非密码安全。

6. 可序列化。

### 线性同余方法参数

这三个参数是 Random 类的核心。

~~~java
private static final long multiplier = 0x5DEECE66DL;
private static final long addend = 0xBL;
private static final long mask = (1L << 48) - 1;
~~~

对应了上文线性同余方法中的各个参数，那么我们可以推断 Random 中的循环定义方程为：

$$
X_{n+1} = (0x5DEECE66DL \times X_n + 0xBL) \; mod \; (1L << 48) - 1
$$

但为什么是 `0x5DEECE66DL`、`0xBL` 和 `1L << 48` 呢？

在 Unix C 库函数中的 `rand48()` 函数族同样是使用这几个数作为同余方法的参数：

~~~c
int __drand48_iterate (unsigned short int xsubi[3], struct drand48_data *buffer)
{
  uint64_t X;
  uint64_t result;
  /* Initialize buffer, if not yet done.  */
  if (__glibc_unlikely (!buffer->__init))
    {
      buffer->__a = 0x5deece66dull;
      buffer->__c = 0xb;
      buffer->__init = 1;
    }
  /* Do the real work.  We choose a data type which contains at least
     48 bits.  Because we compute the modulus it does not care how
     many bits really are computed.  */
  X = (uint64_t) xsubi[2] << 32 | (uint32_t) xsubi[1] << 16 | xsubi[0];
  result = X * buffer->__a + buffer->__c;
  xsubi[0] = result & 0xffff;
  xsubi[1] = (result >> 16) & 0xffff;
  xsubi[2] = (result >> 32) & 0xffff;
  return 0;
}
~~~

关于这几个参数的研究网上鲜有发布，其中占多数的猜测是 `0x5DEECE66DL` 这个乘数搭配 `0xBL` 在模 48 中能够取得较大的周期和较好的随机性。

### 随机数种子

* 为保证线程安全，使用 Long 原子类型对 seed 进行存储。

    ~~~java
    /**
     * The internal state associated with this pseudorandom number generator.
     * (The specs for the methods in this class describe the ongoing
     * computation of this value.)
     */
    private final AtomicLong seed;
    ~~~
  
* 主构造器

    根据传入的 seed，将 seed 始化为 Random 可接受的随机种子。
    
    如果是创建子类实例，则调用子类实现的 `setSeed()` 初始化随机种子。如果是本类实例，则调用 `initialScramble()` 进行初始化。
    `initialScramble()` 方法先对 seed 与乘数进行{异或}(XOR)运算，使 $$X_0$$ 的位分布与乘数一样较为均匀，再对于模数取模，
    使 $$X_0$$ 在模数范围之内。

    ~~~java
    public Random(long seed) {
        if (getClass() == Random.class)
            this.seed = new AtomicLong(initialScramble(seed));
        else {
            // subclass might have overriden setSeed
            this.seed = new AtomicLong();
            setSeed(seed);
        }
    }
  
    private static long initialScramble(long seed) {
        return (seed ^ multiplier) & mask;
    }
    ~~~

* 默认使用当前纳秒数生成随机种子

    但纳秒数也只是传入 seed 的一部分，

    ~~~java
    /**
    * Creates a new random number generator. This constructor sets
    * the seed of the random number generator to a value very likely
    * to be distinct from any other invocation of this constructor.
    */
    public Random() {
        this(seedUniquifier() ^ System.nanoTime());
    }
    
    private static final AtomicLong seedUniquifier = new AtomicLong(8682522807148012L);
  
    private static long seedUniquifier() {
        for (;;) {
            long current = seedUniquifier.get();
            long next = current * 181783497276652981L;
            if (seedUniquifier.compareAndSet(current, next))
                return next;
        }
    }
    ~~~
